# Ch06. 메모리와 캐시 메모리

&nbsp;
## 06-1. RAM의 특징과 종류

    ☑️ **keywords** : 휘발성 저장 장치, 비휘발성 저장 장치, DRAM, SRAM, SDRAM, DDR SDRAM


### ● RAM의 특징

- RAM에는 실행할 프로그램의 명령어와 데이터가 저장
- **휘발성 저장 장치**
    
    전원을 끄면 명령어와 데이터가 모두 날아가는 저장 장치
    
    e.g. RAM
    
- **비휘발성 저장 장치**
    
    전원이 꺼져도 저장된 내용이 유지되는 저장 장치
    
    e.g. 하드디스크, SSD, CD-ROM, USB 메모리같은 보조기억장치
    

### ● RAM의 용량과 성능

- RAM 용량 ↓  실행 시간 ↑ (보조기억장치에서 가져오는 일이 많기 때문)
- RAM 용량이 필요 이상으로 크다고 속도가 이에 비례하여 증가 X

### ● RAM의 종류

- DRAM
- SRAM
- SDRAM
- DDRSDRAM
- DRAM
<br>

- DRAM (Dynamic RAM)
    
    : 저장된 데이터가 동적으로 사라지는 RAM
    
    - 단) 데이터의 소멸을 막기 위해 일정 주기로 데이터를 다시 저장
    - 장) 소비 전력이 ↓, 가격 ↓, 집적도 ↑  → 대용량 설계가 용이!
        
        → 이때문에 일반적인 메모리로 사용함
        
        - cf. 집적도가 높다 = 더 작고 빽뺵하게 만들 수 있다
        
- SRAM (Static RAM)
    
    : 저장된 데이터가 변하지 않는 RAM
    
    - DRAM보다 속도 ↑, 집적도 ↓, 소비 전력 ↑, 가격 ↑
        
        → 메모리로 잘 사용하지 않음
        
    - 메모리가 아닌 ‘대용량으로 만들어질 필요는 없지만 속도가 빨라야 하는 저장 장치’, 예를 들어 캐시 메모리에 사용

- DRAM vs SRAM
    
    
    |  | DRAM | SRAM |
    | --- | --- | --- |
    | 재충전 필요 | O | X |
    | 속도 | 느림 | 빠름 |
    | 가격 | 저렴함 | 비쌈 |
    | 집적도 | 높음 | 낮음 |
    | 소비 전력 | 적음 | 높음 |
    | 사용 용도 | 주기억장치(RAM) | 캐시 메모리 |

- SDRAM (Synchronous Dynamic RAM)
    
    : 클럭 신호와 동기화된, 발전된 형태의 DRAM
    
    - 클럭 타이밍에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받음
    
- DDR SDRAM
    
    : 대역폭(데이터를 주고받는 길의 너비)를 넓혀 속도를 빠르게 만든 SDRAM
    
    - 최근 가장 흔히 사용됨
    - 한 클럭당 하나씩 데이터를 주고받을 수 있는 SDRAM : SDR SDRAM (Single Data Rate SDRAM)

&nbsp;
## 06-2. 메모리의 주소 공간

☑️ **keywords** : 물리 주소, 논리 주소, MMU, 베이스 레지스터, 한계 레지스터


### ● 물리 주소와 논리 주소

- **물리 주소** : 메모리가 사용하는 하드웨어상의 실제 주소
- **논리 주소** : CPU와 실행 중인 프로그램이 사용하는 각각 프로그램에 부여된 주소

- CPU와 메모리가 상호작용을 하려면 물리 주소와 논리 주소 간의 변환이 필요
- 메모리 관리 장치(MMU - CPU와 주소버스 사이에 위치)에 의해 논리 주소와 물리 주소간의 변환이 수행
- MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환

- 베이스 레지스터 : 프로그램의 가장 작은 물리주소, 즉 프로그램의 첫 물리 주소를 저장
- 논리 주소 : 프로그램의 시작점으로부터 떨어진 거리

### 메모리 보호 기법

- 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험 → 논리 주소 범위를 벗어나는 명령어 실행 방지
- 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는 **한계 레지스터** 사용
- 베이스 레지스터 값 ≤ **프로그램의 물리 주소 범위** < 베이스 레지스터 + 한계 레지스터 값
- CPU는 메모리에 접근하기 전에, 

접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 검사하고, 

한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터럽트를 발생시켜 실행 중단시킴

&nbsp;
## 06-3. 캐시 메모리

    ☑️ **keywords** : 저장 장치 계층 구조, 캐시 메모리, 캐시 적중률, 참조 지역성의 원리


시작하기 전에,

CPU가 메모리에 접근하는 시간은 CPU의 연산 속도보다 느리다.

CPU가 연산을 아무리 빨리 한다 해도 메모리에 접근하는 시간이 느리면 CPU의 빠른 연산 속도는 아무런 쓸모가 없을 것이다.

이를 극복하기 위한 장치가 캐시 메모리이다.

### ● 저장 장치 계층 구조

: 컴퓨터가 사용하는 저장 장치들을 'CPU에 얼마나 가까운가'를 기준으로 계층적으로 나타낸 것

- CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느림
- 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비쌈
    
    → '빠른 저장 장치'와 '용량이 큰 저장 장치'는 양립하기 어려움
    

![Ch-6_저장장치계층구조](https://github.com/aivle33-dev-study/cs-study/assets/90406411/114b8b04-4e59-4ad8-a8d7-82e0624094f4)

### ● 캐시 메모리(cache memory)

: CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치

- CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생
    
    ![Ch-6_저장장치계층구조_캐시추가](https://github.com/aivle33-dev-study/cs-study/assets/90406411/921ae6bd-dcf4-497e-801c-0d74345e3297)
    
- 캐시 메모리들은 CPU(코어)와 가까운 순서대로 계층을 구성
- CPU와 가장 가까운 캐시 메모리 : L1 (level 1) 캐시
- CPU와 두 번쨰로 가까운 캐시 메모리 : L2 (level 2) 캐시
- CPU와 세 번째로 가까운 캐시 메모리 : L3 (level 3) 캐시

![Ch-6_캐시메모리](https://github.com/aivle33-dev-study/cs-study/assets/90406411/acf169e1-0c8d-49a2-8688-1cb58bf756ff)

- 일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치
- L1 캐시와 L2 캐시는 코어마다 고유한 캐시 메모리로 할당, L3는 여러 코어가 공유하는 형태

![Ch-6_캐시메모리_멀티코어](https://github.com/aivle33-dev-study/cs-study/assets/90406411/7f6ecfa6-5bc4-4d5b-aa13-3f609496aa84)

멀티코어 프로세서의 캐시 메모리

- 분리형 캐시
    - L1 캐시는 조금이라도 접근 속도를 빠르게 만들기 위해 명령어만을 사용하는 L1 캐시인 **L1I** 캐시와 데이터만을 저장하는 L1 캐시인 **L1D** 캐시로 분리하는 경우도 존

![Ch-6_캐시메모리_분리형](https://github.com/aivle33-dev-study/cs-study/assets/90406411/273aaa34-b36c-4ee8-b0d9-c5dbaad1282d)

### ● 참조 지역성 원리

캐시 메모리는 메모리보다 용량이 작음 → CPU가 사용할 법한 대상을 예측하여 저장

메모리가 보조기억장치의 일부를 복사하여 저장하는 것 처럼 캐시 메모리는 메모리의 일부를 복사하여 저장한다.

- 캐시 히트(cache hit)
    
    자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우
    
- 캐시 미스(cache miss)
    
    자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만, 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우
    
- 캐시 적중률(cache hit ratio)
    
    캐시가 히트되는 비율 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
    
    우리가 사용하는 컴퓨터의 캐시 적중률은 약 85~95%
    

- 캐시 메모리는 **참조 지역성의 원리(locality of reference, principle of locality)** 한 가지 원칙에 따라 메모리로부터 가져올 데이터를 결정
    1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
    2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다
    

**1.  '최근에 접근했던 메모리 공간에 다시 접근하려는 경향'**

- 변수에 저장된 값은 일반적으로 프로그램이 실행되는 동안 여러 번 사용

→ **시간 지역성(temporal locality) :** 최근에 접근했던 메모리 공간에 다시 접근하려는 경향

**2. '접근한 메모리 공간 근처를 접근하려는 경향'**

- CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 한데 모여 있고, 하나의 프로그램 내에서도 관련 있는 데이터들은 모여서 저장
- **공간 지역성(spatial locality)** : 접근한 메모리 공간 근처를 접근하려는 경향
