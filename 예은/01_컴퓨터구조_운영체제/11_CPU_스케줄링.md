# Ch11. CPU 스케줄링
<br>

- **CPU 스케줄링** : 멀티 프로세스 환경에서 프로세스가 효율적으로 동작하기 위해서 공정하게 CPU 자원을 배분하는 것


&nbsp;
## 11-1. CPU 스케줄링 개요

    ☑️ keywords : CPU 스케줄링, 우선순위, 스케줄링 큐, 준비 큐, 대기 큐, 선점형 스케줄링, 비선점형 스케줄링
<br>

### ● 프로세스 우선순위

- 프로세스마다 우선순위가 다름

- 우선순위가 높은 프로세스에는 대표적으로 **입출력 작업이 많은 프로세스**

- 대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행

- But, 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양의 차이가 있음

    - 입출력 작업이 많은 프로세스 = 입출력 집중 프로세스(I/O bound process)

    - CPU 작업이 많은 프로세스 = CPU 집중 프로세스(CPU bound process)

- 따라서, 가장 공정한 스케줄링은 입출력 집중 프로세스를 먼저 처리하는 것
<br>

- e.g. CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다면,

    입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고,
    
    그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당시키는 것이 더 효율적임

    그렇기 때문에 프로세스마다 우선순위를 부여

<br><br>

### ● 스케줄링 큐

- 모든 프로세스의 PCB를 보는 것은 비효율적이기 때문에 운영체제는 프로세스들에 줄을 서서 기다릴 것을 요구

- 이 줄을 `스케줄링 큐`로 구현하고 관리

- 즉, 운영체제는 새로 생성되는 프로세스들, CPU를 이용하고 싶은 프로세스들, 특정 입출력장치를 이용하고 싶은 프로세스들을 큐에 삽입하여 줄 세움
<br>

### ● 큐의 종류

- 준비 큐
    
    CPU를 이용하고 싶은 프로세스들이 서는 줄


- 대기 큐

    대기 큐는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄 
    <br>

- 준비 상태에 있는 프로세스
    
    - 준비 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행 
    
        → 우선순위가 높은 프로세스를 먼저 실행

    - 높은 우선순위는 VIP라고 생각
    <br>

- 대기 상태에 있는 프로세스

    - 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 대기 
    
        → 입출력이 완료되어 완료 인터럽트 발생 
    
        → 작업이 완료된 PCB를 찾고 대기 큐에서 제거 
    
        → 준비 큐로 이동
<br><br>

### ● 선점형과 비선점형 스케줄링

- 다른 급한 프로세스가 CPU를 당장 사용하길 요청한다면?

    → 선점형 스케줄링과 비선점형 스케줄링의 방법을 사용
<br>

▪️ 선점형 스케줄링

- 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식

- 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
<br>

▪️ 비선점형 스케줄링

- 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식

- 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식 
<br>

- 대부분의 운영체제는 선점형 스케줄링 방식을 차용

    |  | 선점형 스케줄링 | 비선점형 스케줄링 |
    | --- | --- | --- |
    | 장점 | 자원 독점을 막고 골고루 자원 배분 가능 | 문맥 교환에서 발생하는 오버헤드가 적음 |
    | 단점 | 문맥 교환 과정에서 오버헤드 발생할 수 있음 | 당장 자원을 사용하는 상황에도 기다려야 함 |
    
&nbsp;
## 11-2. CPU 스케줄링 알고리즘

    ☑️ keywords : 선입 선처리 스케줄링, 최단 작업 우선 스케줄링, 라운드 로빈 스케줄링, 우선순위 스케줄링, 다단계 피드백 큐 스케줄링

<br>

### ● 스케줄링 알고리즘의 종류

- 선입 선처리 스케줄링
  
- 최단 작업 우선 스케줄링
  
- 라운드 로빈 스케줄링
  
- 최소 잔여 시간 우선 스케줄링

- 우선순위 스케줄링

- 다단계 큐 스케줄링
  
- 다단계 피드백 큐 스케줄링
<br><br>

▪️ 선입 선처리 스케줄링 (FCFS: First Come First Served)

- 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식

- 부작용 : 프로세스들이 기다리는 시간이 매우 길어질 수 있음
<br>
    
▪️ 최단 작업 우선 스케줄링 (SJF: Shortest Job First)

- 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식
<br>
    
▪️ 라운드 로빈 스케줄링 (RR: Round Robin)

- 선입 선처리 스케줄링 + 타임 슬라이스

- 타임 슬라이스란 프로세스가 CPU를 사용할 수 있는 정해진 시간

- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 스케줄링 방식

- 타임 슬라이스의 크기가 매우 중요!

    - 클 때 : 선입 선처리 스케줄링과 비슷

    - 작을 때 : 문맥 교환에 발생하는 비용이 커짐
    <br>
    
▪️ 최소 잔여 시간 우선 스케줄링 (SRT: Shortest Remaining Time)

- 최단 작업 우선 스케줄링 + 라운드 로빈

- 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택
<br>
    
▪️ 우선순위 스케줄링

- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위부터 실행

- 우선순위가 높은 프로세스들의 실행이 계속되면서 우선순위가 낮은 프로세스는 연기가 될 수 있음

- 이를 `기아 현상(starvation)` 이라고 함

- 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 `에이징`을 통해 해결 
<br>
    
▪️ 다단계 큐 스케줄링 (Multilevel queue)

- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식

- 큐마다 타임 슬라이스를 지정, 타임 슬라이스의 크기 조정, 다른 스케줄링 알고리즘을 사용할 수 있음
<br>
    
▪️ 다단계 피드백 큐 스케줄링 (Multilevel feedback queue)

- 다단계 큐 스케줄링의 단점) 프로세스들이 큐 사이를 이동할 수 없음
    
    → 우선 순위가 낮은 프로세스는 기아 현상 발생 가능

    → 보완

- 프로세스들이 큐 사이를 이동할 수 있음

- 준비 상태의 프로세스는 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간 실행

    → 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입 .. 이후 반복

- 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 에이징 기법을 적용하여 기아 현상 예방

- 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘임!