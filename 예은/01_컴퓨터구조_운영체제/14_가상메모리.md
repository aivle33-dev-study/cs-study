# Ch14. 가상메모리

&nbsp;
## 14-1. 연속 메모리 할당

    ☑️ keywords : 스와핑, 최초 적합, 최적 적합, 최악 적합, 외부 단편화
<br>

### ● 스와핑

: 메모리 공간이 부족한 현상을 해결하기 위해 대기 상태(입출력) 프로세스, 오랫동안 사용되지 않은 프로세스를 임시로 보조기억장치로 이동시키고, 메모리의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

![IMG_CD4474BAA909-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/73822f9e-5bc6-4101-836b-e5efeebceac7)

- 스왑 영역: 보조기억장치로 이동된 프로세스의 데이터가 보조기억장치에서 차지하는 일부 영역

- 스왑 아웃: 프로세스가 보조기억장치로 이동되는 것

- 스왑 인: 보조기억장치의 스왑영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

- 스왑 아웃 되었던 프로세스가 다시 스왑 인 될때는 스왑 아웃되기 전의 물리 주소와 다른 주소로 적재될 수 있음


- 실행되는 모든 프로세스를 메모리에 저장해서 사용하면 메모리 낭비가 심함

---
<br>

### ● 메모리 할당

- 메모리 내에 빈 공간이 여러개 있을 때 프로세스를 연속적으로 할당하는 방식 3가지

    - 최초 적합: os가 프로세스를 적재할 수 있는 공간을 발견하는 즉시 메모리할당, 검색 최소화 → 빠른 할당

    - 최적 적합: os가 빈 공간을 모두 검색, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치

    - 최악 적합: 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치


<br>

### ● 외부 단편화

: 연속 메모리 할당으로 프로세스가 생기고 종료되고를 반복하다보면 메모리 사이에 빈 공간들이 생김

전체 빈 공간의 메모리 양은 충분하지만 메모리가 부분적으로 있어 특정 프로세스를 진행 못하는 현상

|![IMG_5DA31983AABA-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/f62645f0-001e-42c3-9424-08259dffc24e)|![IMG_5DA31983AABA-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/f62645f0-001e-42c3-9424-08259dffc24e)|
|--|--|


<br>

- 압축
    
    : 메모리 내에 저장된 프로세스를 재배치하여 빈 공간들을 하나로 모으는 방법. 

    모으는 동안 시스템은 일을 중지, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기, 
    
    이동 중 오버헤드를 최소화하는 방법을 결정하기 어려움.
    ![IMG_EA0B16252566-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/f90f3909-9382-4156-9f28-9b89b8a41f5d)


---

&nbsp;

## 14-2. 페이징을 통한 가상 메모리 관리

    ☑️ keywords : 페이징, 페이지 테이블, PTBR, TLB
<br>

**가상 메모리(virtual memory)** 

: 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있는 기술

→ 이를 가능케 하는 기법 : **페이징**, 세그멘테이션

cf. 세그멘테이션
        
    가상 메모리를 같은 크기의 블록으로 분할하는 페이징 기법과 달리,

    세그멘테이션 기법은 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하는 기법
        

---

### ● 페이징(paging)
: 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 자르고, 메모리 물리 공간을 **프레임**이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

외부 단편화의 근본적인 이유인 연속적 할당을 해결!
    
![IMG_D89FF496A436-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/2d84dbfa-3abc-48a1-b388-ae4cd7a456a3)


▪️ **페이징에서의 스와핑 사용**
  
: 메모리에 적재될 필요가 없는 페이지들은 페이지 아웃(스왑 아웃)
    
: 실행에 필요한 페이지들은 메모리로 페이지 인(스왑 인)

![IMG_191472C4FFFB-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/e248d64e-1c2d-490c-b2c4-bd07ac85167c)
    

**→ 프로세스 전체를 메모리에 적재할 필요x, 페이지 단위로 메모리 적재**
    
---
<br>

### ● 페이지 테이블

:  페이지 번호(논리적 메모리)와 프레임 번호(물리적 메모리)를 맵핑

(프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU는 '다음에 실행할 명령어 위치'를 찾기 힘들기 때문)

![IMG_3F051DAB7790-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/fa7c4923-0586-426f-bd14-4918788ee3c5)


=> 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고있기 어려움

즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 ‘다음에 실행할 명령어 위치’를 찾기가 어려워짐

<br>

cf. 내부 단편화

: 모든 프로세스가 페이지 크기에 맞게 잘리는게 아님. 이러한 일부분의 메모리 낭비를 말함


**페이지 테이블 베이스 레지스터(PTBR)**
  - 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재.
  - 각 프로세스들의 페이지 테이블 정보는 각 프로세스의 PCB에 기록됨. 그리고 프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경
  - CPU 내의 레지스터들 중 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블의 시작 주소를 보관


- CPU → 페이지 테이블 접근 → 페이지 테이블에서 프레임 확인 → CPU → 프레임 접근 → 프레임에서 데이터 가져옴

⇒ 메모리에 2번 접근해야함

- 이런 문제를 해결하기 위해 TLB 사용
<br>

- **TLB(Translation Lookaside Buffer) = 캐시 메모리**
    : 일반적으로 MMU내에 TLB라는 페이지 테이블의 캐시 메모리를 두고 참조 지역성에 근거해 최근에 사용된 페이지 위주로 가져와 저장.


---
<br>

### ● 페이징에서의 주소 변환

하나의 페이지 혹은 프레임은 여러 주소를 포괄

그렇기에 특정 주소에 접근하려면 두 가지 정보가 필요

- 어떤 페이지 혹은 프레임에 접근하고 싶은지

- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

![IMG_2B55CCAE9F52-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/4c68bb8b-9ce1-4e63-b0e9-2ac57daf057b)


**특정 주소에 접근하려면**

- 어떤 페이지, 프레임에 접근하고 싶은지

- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져있는지 확인.

페이징 시스템에는  모든 논리 주소가 기본적으로 **페이지 번호**와 **변위**로 이루어져 있음

- 페이지 번호: 접근하고자 하는 페이지 번호, 해당되는 프레임을 알 수 있음

- 변위: 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보

**논리 주소의 변위와 물리 주소의 변위 값은 같다**

- 즉 논리주소<페이지 번호, 변위> ⇒ 물리주소<프레임 번호, 변위>로 변환

- 페이지 번호는 페이지 테이블에서 사용, 변위는 메모리의 프레임에서 사용

---
<br>

### ● 페이지 테이블 엔트리

: 페이지 테이블의 각각의 행들

페이지 테이블 엔트리의 필드에는 페이지 번호, 프레임 번호 외에 대표적으로 유효비트, 보호비트, 참조 비트, 수정 비트가 있음

- 유효 비트(valid bit) : 현재 해당 페이지에 접근 가능한지 여부를 알려줌

페이징 스와핑에서 메모리에 있을 땐 유효비트 1, 보조기억장치에 있으면 0

- 보호 비트(protection bit): 페이지가 읽기만 가능한지 읽기, 쓰기가 다 가능한지. 프로세스의 코드영역과 같이 읽기만 가능할 땐 0, 쓰기가 가능하면 1

- 참조 비트(reference bit): CPU가 페이지에 접근한 적이 있는지 여부. 읽거나 쓰면 1, 접근한 적이 없으면 0.

- 수정 비트(modified bit): 더티 비트라고도 함. 해당 페이지의 데이터가 변경된 적이 있는지 표시. CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조 기억장치와 같은 값을 가짐. → 수정 비트에서 변경된 부분만 보조기억 장치 데이터를 변경하면 됨.

---

&nbsp;
## 14-3. 페이지 교체와 프레임 할당

    ☑️ keywords : 요구 페이징, 페이지 교체 알고리즘, 스레싱, 프레임 할당
<br>

### ● 요구 페이징

: 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법

이름 그대로 실행에 요구되는 페이지만 적재
<br>

- **요구페이징 순서**

1. CPU가 특정 페이지에 접근하는 명령어 실행

2. 유효비트가 1이면 프레임에 접근

3. 유효비트가 0이면 페이지 폴트가 발생

4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효비트 1로 설정

5. 다시 1번부터 실행
<br>

- **페이지 교체**

: 요구 페이징 기법으로 페이지들을 적재하다 보면 메모리가 가득 참 

  → 메모리에 적재된 페이지를 보조기억장치로 내보내야 함. 이때 페이지 교체 알고리즘을 적용

---
<br>

### ● 페이지 교체 알고리즘

: 컴퓨터 성능을 저하시키는 페이지 폴트를 가장 적게 일으키는게 관건

- 페이지 폴트 횟수
- 페이지 참조열
    - 페이지 폴트가 발생하지 않는 연속되는 페이지들을 제거
    
    ```java
    CPU가 참조하는 페이지: 2223555337
    페이지 참조열: 23537
    ```
<br>
    

**● 페이지 교체 알고리즘 종류**

1. FIFO 페이지 교체 알고리즘
: 이후의 페이지를 고려하지 않음
→ 2차 기회 FIFO 페이지 교체 알고리즘
   : 메모리에 오래 머물렀던 페이지의 참조 비트가 1일 경우 0으로 만듬. 참조비트가 0이었으면 보조기억장치로 이동

2. 최적 페이지 교체 알고리즘
: 가장 오랫동안 사용되지 ‘않을’ 페이지를 교체하는 알고리즘

→ 타 페이지 교체 알고리즘에 피해 페이지 폴트 발생 빈도가 가장 낮지만 사용될 페이지를 예측하기 어렵기 때문에 실제 구현이 힘듦

3. LRU 페이지 교체 알고리즘
: 가장 오랫동안 사용되지 ‘않은’ 페이지를 교체하는 알고리즘

페이지 교체 알고리즘의 종류는 매우 다양

**대표적인 페이지 교체 알고리즘들의 기본적인 아이디어는 무엇인지를 이해하는 데에 중점**

---
<br>

### ● 스래싱과 프레임 할당

적합하지 않은 페이지 교체 알고리즘을 사용하거나 프로세스가 사용할 수 있는 프레임 수가 적을수록 페이지 폴트는 자주 발생

**스래싱**: 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제

![IMG_AA8B3C8F2273-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/5d42d00d-c47c-49ec-b3b5-5ad7b30e674e)


![IMG_39F1AF9D7A74-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/d3aa2885-bfc3-49b5-a35f-781e442036b4)

멀티프로그래밍의 정도: 메모리에 동시에 실행되는 프로세스의 수

- 필요 이상으로 프로세스의 수를 늘리면 프로세스들이 사용할 수 있는 프레임수가 적어지기 때문에 페이지 폴트가 지나치게 발생

→ 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않아 스래싱이 발생
    
⇒ os는 각 프로세스들의 최소한의 프레임 수를 파악하고 적당히 할당

<br>

**프레임 할당 방식**

- 정적 할당 방식: 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 프레임의 크기만을 고려한 방식

    - 균등 할당 : 모든 프로세스에 균등하게 프레임 제공. 프로세스의 크기가 다르므로 비합리적 할당

    - 비례할당 : 프로세스 크기에 비례하게 프레임 제공. 일반적으로 프로세스의 크기보다 프로세스를 실행을 해봐야 적당한 프레임의 양을 알 수 있어 마찬가지로 비합리적으로 할당할 수 있음

- 동적 할당 방식: 프로세스의 실행을 보고 할당할 프레임 수를 결정

  - 작업 집합 모델

  - 페이지 폴트 빈도
  
<br>
    
- 페이지 폴트 빈도 사용 방식

2개의 가정에서 생긴 아이디어

    - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 가지고 있음

    - 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 가지고 있음

![IMG_7A852038BC47-1](https://github.com/aivle33-dev-study/cs-study/assets/90406411/88e0710c-baab-4411-87da-e074cd099c4f)

- 페이지 폴트율의 상한선과 하한선을 설정

- 페이지 폴트율이 상한선보다 높으면(많이 발생하면) 프레임 할당

- 페이지 폴트율이 하한선보다 낮으면(메모리 낭비가 심하면) 프레임 회수