# Ch04. CPU의 작동 원리

&nbsp;
## 04-1. ALU와 제어장치

    ☑️ keywords : ALU, 플래그, 제어장치, 제어 신호
<br>

들어가기 전, 1장의 내용을 되짚어보자!

- CPU : 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
- CPU의 구성
    - 계산을 담당하는 **ALU**
    - 명령어를 읽어들이고 해석하는 **제어장치**
    - 작은 임시 저장 장치인 **레지스터**

### ● ALU

<--- ALU가 어떤 정보를 받아들이고, 내보내는지 표현한 img--->

- ALU가 받아들이는 정보
    - 레지스터 : **피연산자**를 받아들임
    - 제어장치 : 수행할 연산을 알려주는 **제어신호**를 받아들임
    - ALU : 레지스터, 제어장치에서 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등의 연산 수행

- ALU가 내보내는 정보
    - 연산 수행 결과 : **숫자, 문자, 메모리 주소**

        → 일시적으로 레지스터에 저장!

        왜냐하면, CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느리기 때문
        
    - **플래그(flag)** : 연산 결과에 대한 추가적인 상태 정보, 플래그 레지스터에 저장됨
        
        
        | 플래그 종류 | 의미 | 사용 예시 |
        | --- | --- | --- |
        | 부호 플래그 | 연산한 결과의 부호 | 1 : 계산 결과: 음수<br> 0 : 계산 결과: 양수 |
        | 제로 플래그 | 얀신 결과가 0인지 여부 | 1 : 연산 결과가 0<br> 0 : 연산 결과가 0 아님 |
        | 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 나타냄 | 1 : 올림수나 빌림수 발생<br> 0 : 올림수나 빌림수 발생 X |
        | 오버플로우 플래그 | 오버플로우가 발생했는지 나타냄 | 1 : 오버플로우 발생<br> 0 : 오버플로가 발생 X |
        | 인터럽트 플래그 | 인터럽트가 가능한지 나타냄 | 1 : 인터럽트 가능<br> 0 : 인터럽트 불가능 |
        | 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 나타냄 | 1 : 커널 모드<br> 0 : 사용자 모드 |

### ● 제어장치

- 제어장치 : 제어 신호를 내보내고, 명령어를 해석하는 부품
- 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

<--- 제어장치가 어떤 정보를 받아들이고, 내보내는지 표현한 img --->

- 제어장치가 받아들이는 정보
    - **클럭**(clock) 신호 : 모든 부품을 움직일 수 있게 하는 시간 단위
        - 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동
        - ALU에서 연산이 수행
        - CPU가 메모리에 저장된 명령어를 읽어들임
        - 컴퓨터의 부품들이 클럭의 신호에 맞춰 작동하는것이지, 한 클럭마다 작동하는것 X
    - 해석해야 할 **명령어**
        - CPU가 해석해야 할 명령어는 명령어 레지스터에 저장됨
        - 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌
    - 플래그 레지스터 속 **플래그 값**
        - 플래그를 참고하여 제어 신호를 발생시킴
    - 제어 버스로 전달된 **제어신호**
        - CPU뿐 아니라 입출력장치를 비롯한 CPU 외부 장치도 제어신호를 발생시킬 수 있음
        - 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들임

- 제어장치가 내보내는 정보
    - CPU 외부에 전달하는 제어 신호
        - 제어 버스로 제어 신호를 보낸다는 의미
        - 제어 신호의 종류
            - 메모리에 전달하는 제어 신호 : 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때
            - 입출력장치에 전달하는 제어 신호 : 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때
    - CPU 내부에 전달하는 제어 신호
        - 제어 신호의 종류
            - ALU에 전달하는 제어 신호 : 수행할 연산을 지시하기 위함
            - 레지스터에 전달하는 제어 신호 : 레지스터간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위함

&nbsp;
## 04-2. 레지스터

    ☑️ keywords : 프로그램 카운터, 명령어 레지스터, 메모리 주소/버퍼 레지스터, 범용/플래그 레지스터, 스택 포인터, 베이스 레지스터

&nbsp;
### ● 반드시 알아야 할 레지스터

- 프로그램 카운터
- 명령어 레지스터
- 메모리 주소 레지스터
- 메모리 버퍼 레지스터
- 플래그 레지스터
- 범용 레지스터
- 스택 포인터
- 베이스 레지스터<br><br>

- 프로그램 카운터 (PC: Program Counter)
    - 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장
    - 명령어 포인터 (IP: Instruction Pointer)라고 부르는 CPU도 있음

- 명령어 레지스터 (IR: Instruction Register)
    - 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
    - 제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤 제어신호를 내보냄

- 메모리 주소 레지스터 (MAR: Memory Address Register)
    - 메모리의 주소를 저장하는 레지스터
    - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침

- 메모리 버퍼 레지스터 (MBR: Memory Buffer Register)
    - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
    - 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값이 메모리 버퍼 레지스터를 거침
    - CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거침
    - 메모리 데이터 레지스터(MDR: Memory Data Register) 라고 부르기도 함
    
- 범용 레지스터 (general purpose register)
    - 이름처럼 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
    - 데이터와 주소를 모두 저장 가능
    - 일반적으로 CPU 안에는 여러 개의 범용 레지스터가 있고, 현대 대다수 CPU는 범용 레지스터 보유
    
- 플래그 레지스터 (flag register)
    - ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장
    - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장
    

### ● 특정 레지스터를 이용한 주소 지정 방식 (1) : 스택 주소 지정 방식

> **스택**과 **스택 포인터**를 이용한 주소 지정 방식

- **스택 포인터** (stack pointer)
    - 스택의 꼭대기를 가리키는 레지스터
    - 즉, 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
    - 스택의 어디까지 데이터가 채워져 있는지에 대한 표시
- 스택 영역
    - 메모리 안에 스택처럼 사용할 영역이 정해져 있음
    - 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역
    

### ● 특정 레지스터를 이용한 주소 지정 방식 (2) : 변위 주소 지정 방식

> 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
    
    
| 연산 코드 | 레지스터 | 오퍼랜드 |
| --- | --- | --- |

- 연산 코드 : 이런 내용을 수행해라
- 레지스터 : 이 레지스터 값과
- 오퍼랜드 : 이 주소를 **더한 곳**에 있는 데이터로<br>

→ 오퍼랜드 필드의 주소와 어떤 주소를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 지정 방식 등으로 나뉨

▪️ 상대 주소 지정 방식 (relative addressing mode)
> 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
- 프로그래밍 언어의 if문과 유사  
- 모든 코드를 실행하는것 X, 분기하여 특정 주소의 코드를 실행할 때 사용됨
        

▪️ 베이스 레지스터 지정 방식
> 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
- 베이스 레지스터 속 기준 주소로 부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻는 방식
- 역할<br>
    - **베이스 레지스터** : 기준 주소
    - 오퍼랜드 : 기준 주소로부터 떨어진 거리
    
&nbsp;
## 04-3. 명령어 사이클과 인터럽트

    ☑️ **keywords** : 명령어 사이클, 인터럽트, 예외, 하드웨어 인터럽트, 인터럽트 서비스 루틴

&nbsp;
시작하기 전에,

- CPU가 하나의 명령어를 처리하는 과정에는 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어를 처리함
    
    → 명령어를 처리하는 정형화된 흐름을 **명령어 사이클**이라고 함
    
- CPU는 정해진 흐름에 따라 명령어를 잘 처리해 나가지만, 흐름이 끊어지는 상황 발생
    
    → 이를 **인터럽트**라고 함
    
&nbsp;
### ● 명령어 사이클

> 프로그램 속 명령어들이 일정한 주기가 반복되며 실행되는 것

- 인출 사이클 (fetch cycle)
    
    : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
    
- 실행 사이클 (execution cycle)
    
    : CPU로 가져온 명령어를 실행하는 단계
    
      제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시킴
    
- 간접 사이클(indirect cycle)
    
    : 명령어를 실행하기 위해 메모리 접근을 한 번 더 하는 단계<br><br>
    

### ● 인터럽트

> CPU의 작업을 방해하는 신호<br>

▪️ **동기 인터럽트** (synchronous interrupts)
> CPU에 의해 발생하며, CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
- **예외**(exception) 라고 부름
    - 폴트(fault) : 예외를 처리한 직후, 예외가 발생한 명령어부터 실행 재개
    - 트랩(trap) : 예외를 처리한 직후, 예외가 발생한 명령어의 다음 명령어부터 실행 재개 (주로 디버깅시 사용)
    - 중단(abort) : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류 발견시 발생
    - 소프트웨어 인터럽트(software interrupt) : 시스템 호출이 발생했을 때 나타남

▪️ **비동기 인터럽트** (asynchronous interrupts)
> 입출력장치에 의해 발생하는 인터럽트
- 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할
- 일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 하지만, 용어의 혼동을 막기 위해 ”**하드웨어 인터럽트**” 라는 용어를 사용

▪️ 하드웨어 인터럽트
- 알림과 같은 인터럽트
- CPU는 입출력 작업 도중에도 효율적인 명령어 처리를 위해 하드웨어 인터럽트 사용
    
▪️ 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴** 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 ’순서-4’에서 백업해 둔 작업을 복구하여 실행 재개

&nbsp;
▪️ 알아야 할 용어
- 인터럽트 요청 신호
    
    : CPU의 작업을 방해하는 인터럽트에 대한 요청
    
- 인터럽트 플래그
    
    : 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그(비트)
    
    - CPU가 인터럽트 요청을 수욜하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 상태여야 함
    - 막을 수 없는 인터럽트 (non maskable interrupt)
        
        모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님
        
        인터럽트 플래그가 불가능으로 설정되어 있더라도 무시할 수 없는 인터럽트 요청 (우선순위가 가장 높은 인터럽트)
        e.g. 정전, 하드웨어 고장
        

- **인터럽트 서비스 루틴** (ISR: Interrupt Service Routine)
    - 인터럽트 핸들러 (interrupt handler)
    - 인터럽트를 처리하는 프로그램
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
- 인터럽트 벡터(interrupt vector)
    - 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
    - cf. CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음

&nbsp;
정리하면,
- CPU가 인터럽트를 처리한다
- 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다!

<--- 명령어 사이클 img --->
