# Ch08. 입출력장치

&nbsp;
## 08-1. **장치 컨트롤러와 장치 드라이버**

    ☑️ **keywords** : 장치 컨트롤러, 장치 드라이버
<br>

### ● 장치 컨트롤러

입출력 장치는 CPU, 메모리보다 다루기 까다로움 (이유 2개)

- 입출력장치의 종류가 너무 많음
    - 키보드, 모니터, USB, SSD, 마우스, 프린터 등 → 장치마다 속도, 데이터, 전송 형식 등도 다양
    - 다양한 입출력장치와 정보를 주고 받는 방식을 규격화하기 어려움
- CPU와 메모리의 데이터의 전송률은 높지만 입출력장치의 데이터 전송률은 낮음
    - 전송률(transfer rate) : 데이터를 얼마나 빨리 교환할 수 있는지 나타내는 지표
    - 전송률의 차이는 CPU와 메모리, 입출력장치 간의 통신을 어렵게 함
<br>

- 위와 같은 이유로 입출력장치는 컴퓨터에 직접 연결되지 않고 `장치 컨트롤러(device controller)`라는 하드웨어를 통해 연결
- 이는 `입출력 제어기(I/O controller)`, `입출력 모듈(I/O module)` 등으로 다양하게 불림
- 모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 정보를 주고받고, 장치 컨트롤러는 하나 이상의 입출력장치와 연결
<br>

- 장치 컨트롤러의 역할
    - CPU와 입출력장치 간의 통신 중개
    - 오류 검출
    - 데이터 버퍼링
        - 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼(buffer)라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법
        - 버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나, 데이터를 한 번에 많이 받아 조금씩 내보내는 방법

- 장치 컨트롤러의 내부 구조
    - 데이터 레지스터 (data register)
        - CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
        - 버퍼 역할
        - 최근 주고받는 데이터가 많은 입출력장치에서는 레지스터 대신 RAM을 사용하하기도 함
    - 상태 레지스터 (status register)
        - 입출력장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 입출력장치에 오류는 없는지 등의 상태 정보가 저장
    - 제어 레지스터 (control register)
        - 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장

### ● 장치 드라이버(device driver)
- 장치 컨트롤러의 동작을 감지, 제어 → 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램
- 장치 컨트롤러가 입출력장치를 연결하기 위한 하드웨어적인 통로라면, 장치 드라이버는 소프트웨어적인 통로임

&nbsp;
## 08-2. **다양한 입출력 방법**

    ☑️ **keywords** : 프로그램 입출력, 메모리 맵 입출력, 고립형 입출력, 인터럽트 기반 입출력, DMA 입출력, 입출력 버스
<br>

### ● 프로그램 입출력(programmed I/O)

- 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 입출력 명령어로써 장치 컨트롤러와 상호작용

- 메모리에 저장된 정보를 하드 디스크에 **백업**하는 상황 (= 하드 디스크에 새로운 정보 **쓰기**)
    1. CPU는 하드 디스크 컨트롤러의 `제어 레지스터`에 `쓰기` 명령 내보내기
    2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 → 상태 레지스터에 `준비 완료` 표시
    3. (1) CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디슼의 준비 여부를 확인
        
        (2) 하드 디스크가 준비되었다면, 백업할 메모리의 정보를 데이터 레지스터에 쓰기
        
        백업 작업이 끝나지 않았다면 1번부터 반복하고, 끝났다면 작업 종료
<br> 

### CPU가 장치 컨트롤러의 레지스터 값을 읽고 쓰는 방법

- **메모리 맵 입출력(memory-mapped I/O)**
    - 메모리에 접근하기 위한 주소 공간, 입출력장치에 접근하기 위한 주소 공간 → 하나의 주소 공간으로 간주하는 방법
- **고립형 입출력(isolated I/O)**
    - 메모리를 위한 주소 공간, 입출력장치를 위한 주소 공간 → 분리하는 방법
    - 입출력 전용 명령어 사용
    
    | 메모리 맵 입출력 | 고립형 입출력 |
    | --- | --- |
    | 메모리와 입출력장치는 같은 주소 공간 사용 | 메모리 입출력장치는 분리된 주소 공간 사용 |
    | 메모리 주소공간이 축소됨 | 메모리 주소 공간이 축소되지 않음 |
    | 메모리와 입출력장치에 같은 명령어 사용 가능 | 입출력 전용 명령어 사용 |
<br>

### ● 인터럽트 기반 입출력

: 장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행

- 인터럽트 : CPU는 장치 컨트롤러에 입출력 작업을 명령하고, 장치 컨트롤러가 입출력장치를 제어하며 입출력을 수행하는 동안 CPU는 다른 일을 함

- cf. 폴링(polling)
    - 입출력 장치의 상태는 어떤지, 처리할 데이터가 있는지를 주기적으로 확인하는 방식
    - 폴링 방식은 인터럽트 방식보다 CPU의 부담이 더 큼!
<br>

### 여러 입출력장치에서 인터럽트가 동시에 발생한다면?

- 인터럽트가 발생한 순서대로 인터럽트를 처리하는 방법
    - 인터럽트 A를 처리하는 도중 발생한 또 다른 인터럽트 B의 요청을 받아들이지 않고, 인터럽트 A 서비스 루틴이 끝나면 그때 B 서비스 루틴을 실행
    - 현실적으로 전부 순차적으로만 해결할 수 없음
    - `CPU는 인터럽트 간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리`
    
- 프로그래머블 인터럽트 컨트롤러(PIC: Programmable Interrupt Controller)
    - 다중 인터럽트를 처리하기 위해 사용하는 하드웨어
    - 우선순위를 반영하여 다중 인터럽트를 처리하는 방법 중 대중적으로 사용되는 방법
    - 여러 장치 컨트롤러에 연결되어 장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤 CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 장치
    
- **PIC의 다중 인터럽트 처리 과정**
    1. PIC가 장치 컨트롤러에서 `인터럽트 요청 신호(들)`를 받아들임
    2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 `인터럽트 요청 신호`를 보냄
    3. CPU는 PIC에 `인터럽트 확인 신호`를 보냄
    4. PIC는 데이터 버스를 통해 CPU에 `인터럽트 벡터`를 보냄
    5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 `인터럽트 서비스 루틴`을 실행
    
    PIC가 무시할 수 없는 인터럽트인 `NMI(Non-Maskable Interrupt)`까지 우선순위를 판단 X
    
    NMI는 우선순위가 가장 높아 우선순위 판별이 불필요하기 때문    
<br>

### ● DMA(Direct Memory Access) 입출력

- 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식
- DMA 입출력을 하기 위해서는 시스템 버스에 연결된 `DMA 컨트롤러`라는 하드웨어가 필요
    
    
- DMA 입출력 과정
    1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령
    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
    이때, DMA 컨트롤러는 필요한 경우 메모리에 직접 접근해 정보를 읽거나 씀
    3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림
    
    - cf. 메모리 사이에 주고받을 데이터는 CPU를 거치지 않음
    CPU는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 되기 때문에 작업 부담 ↓
    CPU는 오로지 입출력의 시작과 끝에만 관여
    
- 문제) DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근 가능, But `시스템 버스`는 공용 자원이기에 동시 사용 불가능 → 아래의 두가지 방법!
    1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
    2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용
    - cf. 사이클 스틸링(cycle stealing)
        - 이러한 DMA의 시스템 버스 이용이 CPU 입장에서는 마치 버스에 접근하는 주기를 도둑 맞는 기분

- 입출력 버스
    - DMA를 위해 1번 메모리에 접근할 때마다 시스템 버스를 2번 사용하게 되는 부작용 발생
    → DMA 컨트롤러와 장치 컨트롤러들을 `입출력 버스(input/output bus)`라는 별도의 버스에 연결하여 해결
    - 입출력 버스에는 `PCI(Peripheral Component Interconnect) 버스`, `PCI Express(PCIe) 버스` 등 여러 종류가 있음
