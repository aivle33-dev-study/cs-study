# Chapter 04. CPU의 작동 원리


## 04 - 1 ALU와 제어장치

<br>

    Keyword : ALU, 플래그, 제어장치, 제어 신호


- ### ALU

    <p align="center"><img src="./image/ALU.png" width="50%"></p>

    #### 받아들이는 정보

    `레지스터`로부터 `피연산자`를 받아들이고, `제어장치`로부터 수행할 연산을 알려주는 `제어 신호`를 받아들임

    #### 내보내는 정보

    연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있음

    이 결과 값은 바로 메모리에 저장되지 않고 `일시적으로 레지스터에 저장`

    Why? 
    
    ALU가 연산할 때마다 연산 결과를 메모리에 저장하면 CPU가 메모리가 접근하는 횟수가 늘어나기 때문에 느려짐
---
- ### 플래그
    
    계산 결과와 함께 플래그도 내보냄
    
    ex) 연산 결과가 음수일 때, 연산 결과가 레지스터보다 클 때(오버플로우)

    대표적인 플래그의 종류

    - 부호 플래그 : 어떤 부호인지

    - 제로 플래그 : 0인지

    - 캐리 플래그 : 올림수, 빌림수가 발생했는지

    - 오버플로우 플래그 : 오버플로우가 발생했는지

    - 인터럽트 플래그 : 인터럽트가 가능한지

    - 슈퍼바이저 플래그 : 커널 모드 or 사용자 모드

    이러한 플래그들은 `플래그 레지스터`에 저장됨
---
- ### 제어장치

    제어 신호를 내보내고, 명령어를 해석하는 장치

    제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호

    <p align="center"><img src="./image/제어장치.png" width="60%"></p>

    #### 받아들이는 정보

    - 클럭 신호

        부품을 움직일 수 있게 하는 시간 단위

        클럭의 주기에 맞춰 데이터가 이동하거나, 연산이 수행되는 등의 일이 일어남
        
        But, 컴퓨터 부품은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 것은 아님

    - 해석해야 할 명령어

        `명령어 레지스터`에 저장된 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 부품들에게 수행해야 할 내용을 알려줌

    - 플래그 레지스터 속 플래그 값

        중요한 참고 사항인 플래그 레지스터에서 플래그 값을 받아들이고 제어 신호를 발생시킴

    - 시스템 버스(제어 버스)로 전달된 제어 신호

        제어 신호는 CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생

    #### 내보내는 정보

    - CPU 외부에 전달하는 제어 신호

        제어 장치가 메모리에 저장된 값을 읽거나 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보냄

        입출력장치도 마찬가지

    - CPU 내부에 전달하는 제어 신호

        수행할 연산을 지시하기 위한 ALU에 전달하는 제어 신호와 데이터를 이동시키거나 명령어를 해석하기 위해 레지스터에 전달하는 제어 신호

---
<br>

## 04 - 2 레지스터
<br>

    Keyword : 프로그램 카운터, 명령어 레지스터, 메모리 주소/버퍼 레지스터, 범용/플래그 레지스터, 스택 포인터, 베이스 레지스터

- ### 레지스터의 종류 1

    프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장

    즉, 레지스터만 잘 관찰해도 프로그램의 자세한 실행 과정을 알 수 있음

    - `프로그램 카운터`

        메모리에서 읽어 들일 명령어의 주소를 저장

        명령어 포인터라고 부르기도 함

    - `명령어 레지스터`

        방금 메모리에서 읽어 들인 명령어를 저장

        제어 장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냄

    - `메모리 주소 레지스터`

        메모리의 주소를 저장

        CPU가 읽어 들이고자 하는 주소값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침

    - `메모리 버퍼 레지스터`

        메모리와 주고받을 값(데이터와 명령어)을 저장


        데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침

    ### 메모리에 저장된 프로그램을 실행하는 과정

    <p align="left"><img src="./image/레지스터1.png" width="40%"></p>

    CPU로 실행할 프로그램이 1000번지부터 1500번지까지 저장되어 있다고 가정하고 1000번지에는 1101(2)가 저장되어있다고 가정

    <br>

    <p align="left"><img src="./image/레지스터2.png" width="60%"></p>

    프로그램을 처음부터 실행하기 위해 프로그램 카운터에는 1000이 저장. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미

    <br>

    <p align="left"><img src="./image/레지스터3.png" width="60%"></p>


    1000번지를 읽어 들이기 위해 주소 버스로 1000번지를 내보냄. 이를 위해 메모리 주소 레지스터에는 1000이 저장

    <br>


    <p align="left"><img src="./image/레지스터4.png" width="60%"></p>

    '메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐

    <br>


    <p align="left"><img src="./image/레지스터5.png" width="60%"></p>

    메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 함

    <br>


    <p align="left"><img src="./image/레지스터6.png" width="60%"></p>


    메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동
    <br>

    제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생

    이처럼 프로그램 카운터는 지속적으로 증가하며 다음 명령어를 읽어 들일 준비를 함. 이 과정이 반복되며 CPU는 프로그램을 차례대로 실행

    ---


- ### 레지스터의 종류 2

    - `플래그 레지스터`

        연산 결과 또는 CPU상태에 대한 부가적인 정보를 저장

    - `범용 레지스터`

        다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터

        메모리 버퍼 레지스터는 데이터 버스로 주고 받을 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 내보낼 주소값만 저장하지만 범용 레지스터는 데이터와 주소를 모두 저장할 수 있음

        일반적으로 CPU 안에 여러 개의 범용 레지스터가 있고, 현재 대다수의 CPU는 모두 범용 레지스터를 가지고 있음

---

- ### 주소 지정 방식에 사용되는 특별한 레지스터

    - `스택 포인터`

        <p align="left"><img src="./image/스택포인터.png" width="60%"></p>

        스택 주소 지정 방식이라는 주소 지정 방식에 사용

        스택에 마지막으로 저장한 값의 `위치`를 저장하는 레지스터

    
    - `베이스 레지스터`



- ### 스택 주소 지정 방식

    

    스택과 스택 포인터를 이용한 주소 지정 방식

    <p align="left"><img src="./image/스택영역.png" width="60%"></p>

    스택은 메모리 안에 스택처럼 사용할 영역으로 존재. 이를 스택 영역이라고 함. 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역 

- ### 변위 주소 지정 방식

    <p align="left"><img src="./image/변위주소지정방식.png" width="60%"></p>

    오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

    - 상대 주소 지정 방식

        <p align="left"><img src="./image/상대주소지정방식.png" width="60%"></p>

        오퍼랜드와 프로그램 카운터 값을 더하여 유효 주소를 얻는 방식

        if문과 유사하게 모든 코드를 실행하는 것이 아닌 분기하여 특정 주소의 코드를 실행할 때 사용

    - 베이스 레지스터 주소 지정 방식

        <p align="left"><img src="./image/베이스레지스터주소지정방식.png" width="60%"></p>

        오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
        
        이점은?


---
<br>

## 04 - 3 명령어 사이클과 인터럽트
<br>

    Keyword : 명령어 사이클, 인터럽트, 예외, 하드웨어 인터럽트, 인터럽트 서비스 루틴

- ### 명령어 사이클

    프로그램 속 각각의 명령어들을 처리하는 정형화된 흐름

    ex ) 메모리에 저장된 명령어 하나를 실행한다고 가정

    첫번째 과정 : 명령어를 메모리에서 CPU로 가져옴(인출 사이클)

    두번째 과정 : 인출된 명령어를 실행(실행 사이클)

    수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행

    명령어를 CPU로 가져왔다고 하더라고 곧바로 실행할 수 없는 경우도 있음 

    ex ) 간접 주소 지정 방식에서는 명령어를 실행하기 위해 메모리 접근을 한 번 더 해야하기 때문에 바로 실행 사이클에 돌입할 수 없음 이를 간접 사이클이라고 함

- ### 인터럽트

    CPU의 작업을 방해하는 신호

    - 동기 인터럽트 = 예외

        CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트


    - 비동기 인터럽트 = 하드웨어 인터럽트

        입출력장치에 의해 발생하는 인터럽트

        ex ) CPU가 프린터에 출력을 명령했지만 입출력장치는 CPU보다 속도가 현저히 느리기 때문에 CPU는 프린터가 언제 프린트를 끝낼지 모르기 때문에 프린터의 완료 여부를 확인해야 함. 이럴 때 하드웨어 인터럽트를 이용함으로써 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 함.

    #### 하드웨어 인터럽트 처리 순서

    1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보냄
    
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인

    3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인

    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업

    5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행

    6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구하여 실행을 재개

    낯선 단어들 정리

    - 인터럽트 요청 신호
        
        CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트하기 전에는 CPU에 물어보는 신호

    - 인터럽트 플래그

        CPU의 인터럽트 요청을 수용하기 위해서 인터럽트 플래그가 활성화되어 있어야 함

        CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않아야 한다면 플래그는 불가능으로 설정됨

        다만, 무시할 수 없는 하드웨어 인터럽트도 있음. 정전, 하드웨어 고장 등

    - 인터럽트 서비스 루틴(인터럽트 핸들러)

        어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

        CPU가 인터럽트를 처리한다라는 말은 인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 다시 돌아온다라는 의미

    - 인터럽트 벡터

        인터럽트 서비스 루틴을 식별하기 위한 정보

        입출력장치마다 인터럽트 서비스 루틴이 다르므로 이들을 구분하기 위해 인터럽트 벡터를 사용

    인터럽트 요청을 받기 전까지 CPU가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 마저 수행을 해야하기 때문에 작업 내역을 스택에 백업해둬야 함

    해당 스택에는 프로그램 카운터 값, 메모리 주소 레지스터 값 등 프로그램을 재개하기 위해 필요한 모든 내용이 담겨져 있음

---

### 결론

CPU는 다음과 같은 과정을 반복해 나가며 프로그램을 실행함


<p align="center"><img src="./image/CPU실행과정.png" width="80%"></p>